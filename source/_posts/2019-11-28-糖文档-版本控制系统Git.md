title: 糖文档-版本控制系统Git
date: 2019-11-28 17:46:06
catalog: true
toc-number: false
tags: [版本控制]
header-img: back.webp
header-color: rgb(65,57,50)
tag-color: rgb(65,57,50)

---



**<font size=6>前言</font>**

---

*注：糖文档是基于和官方文档同样完整但更加有趣易读的思想，在官方文档的基础上加以博主自己的理解而成的系列文档*

Git不能提高代码质量，但是可以让你大胆得去进行各种尝试

> Git —The stupid content tracker(傻瓜内容跟踪器)
>
> ——***Linus Benedict Torvalds***

**<font size=6>正文</font>**

---

## 1. 版本控制

​	版本控制是对程序开发过程中各种程序，配置文件及说明文档等文件变更的管理。

​	主要作用是：

   - 快速便捷得回溯到项目过去某个时间点的状态，通俗点来说就是一键**ctrl+z**到想要回溯的版本
   - 并行开发

​	目前主要应用以SVN( subversion )为代表的集中式版本控制系统和以Git为代表的分布式版本控制系统

​	![集中式](2-1.webp)

![分布式](2-2.webp)

|      |                      集中式版本控制系统                      |                      分布式版本控制系统                      |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 优点 |   代码存放在单一服务器，便于项目管理<br />所需存储空间较少   | 版本控制在本地进行，对服务器的依赖小<br>版本控制时存放完整索引,回滚速度快<br />分支合并迅速，适合上千个分支的并行开发 |
| 缺点 | 对服务器稳定性要求较高，容易出现单点故障<br />每个版本存储的是差异，版本回滚速度慢 |                     所需存储空间较大<br>                     |

## 2 . Git概述

### 2.1 起源

​	Git是由*Linus Benedict Torvalds*开发的对于任意规模项目都快速有效的开源免费**分布式版本控制系统**。

​	当年~~Linux~~*Linus*创建了开源的Linux, 起初项目的管理维护工作都由手工完成，但是随着项目的不断扩大，绝大多数Linux内核的维护工作都花费在了这些重复且枯燥的事务上。到了2002年，商业版本控制软件BitKeeper授权整个项目组基于一定协议免费使用，但是Linux项目的大牛们觉得商业软件不符合开源共享的思想，就在社区内破解了这款软件，这使得开发BitKeeper的公司不再授权免费使用。*Linus*想这么大的项目不能没有自动化的版本控制，但是使用商业软件又被限制住了腿脚，不如自己写一个。不多久，他们就写出了一个设计更简单但是速度更快操作更简易的版本控制系统Git，并且开放了Git的源代码，每个人每个公司都可以免费使用。自诞生自2005年，Git发展迅速，现在已成为各大公司首选的版本控制系统

### 2.2 特性

**直接记录快照，而非差异比较**

![集中式与分布式回滚对比](2-3.png)

Git对待数据更像是快照流。 每次你提交更新或在 Git 中保存项目状态时，它会对当时的全部文件制作一个快照并保存这个快照的索引。

**近乎所有操作都在本地执行**

 因为每个用户都保存着项目的完整记录， 所以在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息 。这不仅意味着超凡的速度，也意味着即使离线或者没有VPN也可以继续工作。

**保证数据完整**

Git使用校验和确保数据每一比特的完整性。Git中所有数据在存储前都计算校验和，然后以校验和来引用。无论以何种方式都不可能在Git不知情时更改任何文件内容或目录内容，如果在传送中丢失信息或损坏文件，Git也能发现。

**分支**

Git的分支模型是它区分于其他版本控制系统的主要特征。Git建议我们拥有多个独立的本地分支，创建、合并或者删除这些分支都只需要几秒钟的时间。Git会彻底得改变我们的工作方式，无论是个人开发还是团队合作

分支可以用来：

- **无忧实验**  创建一个分支用来尝试新点子或者应用一个补丁，如果有效，将他们合并到主分支即可，如果无效，也可以方便得回溯到项目之前状态，大胆去尝试你的新点子吧!

- **多分支协同工作** 一个应用于生产环境的分支，一个用来合并测试的分支和其他一些用来日常工作（比如改bug的小分支）<br><img src="branches@2x.png" alt="branches" style="zoom:50%;" />
- **分支测试** 为每一个新特性创建一个新分支，测试完毕合并到主分支后删除

**体积小速度快**

Git几乎所有的操作都在本地执行，这使得它和必须依赖与服务器不断通信的集中式版本控制系统相比有巨大的速度优势。Git是为Linux内核的工作而创建的，这意味着从第一天开始它就必须能够应对大型存储库。Git是用C编写的（~~C语言是最好的语言，总有一天我会精通它~~），减少了使用高级语言的运行时开销。

**分布式**

Git是一个分布式的版本控制系统，这意味着每个终端都保存着项目的完整历史记录（基于高效压缩，我们不需担心它的体积过大），但是这有什么好处呢？

- 多个备份<br>

- 任意规模<br>由于Git的分布式特性和出色的分支系统，可以相对轻松得实现近乎无限数量的工作流

- 任意形式的工作流<br>*[注:工作流指 业务过程的部分或整体在计算机应用环境下的自动化”，可简单理解为工作过程和工作规则] *

  - 颠覆式工作流(Subversion-Style Workflow)<br>在你提交(push)代码时，如果有团队成员已经提交了代码，则你必须先获取(fetch)别人提交的代码才能提交。<br>![颠覆式工作流](2-4.png)
  - 集成管理工作流(Integration Manager Workflow)<br>集成管理员管理一个集成仓库，开发者从集成仓库克隆代码到本地库，在本地开发后把代码推送到自己的独立存储库并要求集成管理员提取这些更改合并到集成仓库<br>![集成管理工作流](2-5.png)
  - 独裁者和中尉工作流(Dictator and Lieutenants Workflow)<br>适用于更大规模的项目。”独裁者“合并”中尉“提交的代码到集成仓库，”中尉“合并自己所管项目参与者提交的代码。每个参与者都可以从集成仓库克隆代码到本地<br>![独裁者和中尉工作流](2-6.png)

## 3. 重要概念

### 3.1 三个工作区域

- **工作目录**

  工作目录是对项目的某个版本独立提取出来放在磁盘上供使用和修改的内容

- **暂存区域（索引）**

  暂存区是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中

- **Git仓库**

  Git仓库是保存项目数据和历史版本的地方，是Git中最重要的部分
  
  <img src="areas.png" alt="areas" style="zoom: 50%;" />

### **3.2 文件生命周期**

工作目录下面的所有文件都只有两种身份:`未跟踪`、`已跟踪`

`已跟踪的文件`是指那些被纳入版本控制的文件，在上一次快照中有他们的记录。工作目录中除已跟踪文件外的所有文件都为`未跟踪文件`，他们既不存在于上次快照的记录中，也没有放入暂存区

- **已提交(committed)**

  已提交表示数据已安全得保存在Git仓库中

- **已修改(modified)**

  已修改表示文件在工作目录做了修改，但是尚未暂存

- **已暂存(staged)**

  已暂存表示下次提交的快照中会包含这个文件

<img src="state.png" alt="state" style="zoom: 67%;" />

### 3.3 **基本工作流程**

- 在工作目录中修改文件
- 暂存文件，将文件快照放到暂存区
- 提交更新，找到暂存区文件，将快照永久性存储到Git仓库

## 4. Git内部原理

学习这部分对理解Git的用途和强大至关重要，但对于初学者来说可能有点难于理解。在学习过程中可以先学习这一部分也可以最后再学习这一部分。本节主要面对底层命令，它有助于说明Git是如何完成工作的。如果只是简单使用Git，不需要记住这些命令。

### 4.1 目录结构

<img src="catalog.png" alt="图片1" style="zoom: 50%;" />

创建暂存区后还会生成`index 文件`保存暂存区信息。

在这一节我们重点讨论: `objects目录`、`refs目录`、`HEAD文件`和`(待创建的)index文件`

### 4.2 Git对象

#### 数据对象

Git核心部分是一个简单的键值对数据库。可以向数据库插入任何内容，它会返回一个键值，通过该键值可以在任意时刻重新检索该内容。下面通过底层命令`hash-object`来演示。

**初始化Git仓库，并存入一些数据**

- `hash-object -w --stdin` 向数据库插入内容
  - `-w` 指示该命令存储数据对象，如果不指定该选项,命令仅返回对应的键值
  - `--stdin` 指示该命令从标准输入读取内容，如果不指定该选项，需要在命令尾部加上待存储文件路径

```shell
# 初始化Git仓库
$ git init	
Initialized empty Git repository in C:/Users/Administrator/Desktop/test/.git/

# Git对objects目录进行了初始化，并创建了空的info和pack目录
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack

#存入值为"helloWorld"的数据
$ echo 'helloWorld' | git hash-object -w --stdin  
7423c81faa8c815b6e8a1742fcc321d457cfaab0 
```

存储命令输出一个由*待存储信息*外加一个*头部信息*一起做SHA-1校验运算得到的校验和`7423c81faa8c815b6e8a1742fcc321d457cfaab0`

**查看Git如何存储数据**

```shell
# 查看Git如何存储数据
$ find .git/objects -type f 
.git/objects/74/23c81faa8c815b6e8a1742fcc321d457cfaab0
```

刚才存储的数据对应了一条内容。校验和的前两个字符用于命名子目录*74/*，剩下的38个字符作为文件名`23c81faa8c815b6e8a1742fcc321d457cfaab0`

**从Git取出数据**

- `git cat-file -p SHA-1值` 从Git取出数据
  - `-p`指示该命令自动判断内容类型，并显示格式友好内容

```shell
# 从Git取出数据
$ git cat-file -p 7423c81faa8c815b6e8a1742fcc321d457cfaab0
helloWorld
```

**查看数据类型**

- `git cat-file -t SHA-1值` 返回存储的对象类型

```shell
# 查看数据类型
$ git cat-file -t 7423c81faa8c815b6e8a1742fcc321d457cfaab0 
blob
```

给定对象的SHA-1值，可以获取Git内部存储的任何对象类型，可以看到此处存储的为`数据对象(blob object)`类型

以上演示了往Git中存入数据和取出数据，这些操作也可以作用于文件内容，接下来对文件进行一个简单的版本控制

**创建一个新文件，并将其存入数据库**

```shell
# 创建新文件
$ echo 'version1' > test.txt

# 存入数据库
$ git hash-object -w test.txt
5bdcfc19f119febc749eef9a9551bc335cb965e2
```

**向文件内写入新内容，并存入数据库**

```shell
# 向文件内写入新内容
$ echo 'version' > test.txt

# 存入数据库
$ git hash-object -w test.txt
088eda41aa61dc62fefef5d183a1f703bb01bfa6
```

**查看数据库内容**

```shell
# 查看数据库内容
$ find .git/objects -type f
.git/objects/08/8eda41aa61dc62fefef5d183a1f703bb01bfa6 # 第二次创建文件的第二个版本
.git/objects/5b/dcfc19f119febc749eef9a9551bc335cb965e2 # 第二次创建文件的第一个版本
.git/objects/74/23c81faa8c815b6e8a1742fcc321d457cfaab0 # 第一次创建的文件
```

**恢复文件内容到第一个版本**

```shell
# 恢复文件内容到第一个版本
$ git cat-file -p 5bdcfc19f119febc749eef9a9551bc335cb965e2 > test.txt

# 查看恢复后文件内容
$ cat test.txt
version1
```

**恢复文件内容到第二个版本**

```shell
# 恢复文件内容到第二个版本
$ git cat-file -p 088eda41aa61dc62fefef5d183a1f703bb01bfa6 > test.txt

# 查看恢复后文件内容
$ cat test.txt
version
```

**对应的高层命令**

```shell
# 初始化
$ git init
Initialized empty Git repository in C:/Users/Administrator/Desktop/新建文件夹/.git/
$ echo 'niceCommand' > nice.txt

# 将文件加入暂存区
$ git add nice.txt
warning: LF will be replaced by CRLF in nice.txt.
The file will have its original line endings in your working directory

# 查看
$ find .git/objects -type f
.git/objects/5b/49cc806c7a41c25d152f69ac20a504a61d8037
```

可以看到，将待跟踪文件加入暂存区时会将其存储到`.git/objects`下对应的子目录中,本例为`.git/objects/5b/49cc806c7a41c25d152f69ac20a504a61d8037`

#### 树对象

数据对象并没有保存文件名，只保存了文件的内容。树对象可以解决文件名的保存问题，也允许我们将多个文件组织到一起

一个树对象包含一条或多条树对象记录，每条记录含有一个指向数据对象或者子树对象的SHA-1指针以及相应的模式、类型、文件名信息。(类似于windows的文件夹，文件夹可以再包含文件或者文件夹)

**创建树对象**

通常，Git通过某一时刻暂存区(即index区域)所表示的状态创建并记录一个对应的树对象。因此，为创建一个树对象，首先需通过暂存一些文件创建一个暂存区

- `git update-index --add --cacheinfo 100644 SHA-1值 文件名` 将一个文件存入暂存区
  - `--add`	如果此文件不在暂存区，则应该指定该选项
  - `--cacheinfo` 如果将添加的文件位于Git数据库而不是当前目录(即先前版本)，应指定该选项
  - `100644` 表示普通文件的文件模式，其他包括：`100775`可执行文件、`120000`符号链接
- `write-tree` 将暂存区内容写入树对象。无需指定`-w`选项，如果某个树对象此前不存在会自动创建

```shell
# 将test第一个版本存入暂存区
git update-index --add --cacheinfo 100644 \
> 5bdcfc19f119febc749eef9a9551bc335cb965e2 test.txt

# 将暂存区内容写入树对象
$ git write-tree 5bdcfc19f119febc749eef9a9551bc335cb965e2
c89f1e026cabe89e7e80a139544a9ae5efc9b470

# 查看新生成到树对象的内容
$ git cat-file -p c89f1e026cabe89e7e80a139544a9ae5efc9b470
100644 blob 5bdcfc19f119febc749eef9a9551bc335cb965e2    test.txt

# 验证新生成的树对象类型
$ git cat-file -t c89f1e026cabe89e7e80a139544a9ae5efc9b470
tree
```

**再创建一个包括`test.txt`文件第二个版本和一个新文件的树对象**

```shell
# 生成新文件
$ echo 'new file' > new.txt

# 将新文件加入暂存区
$ git update-index --add new.txt

# 将test.txt的第二个版本加入暂存区
$ git update-index --add --cacheinfo 10064 \    # "\"表示换行
> 088eda41aa61dc62fefef5d183a1f703bb01bfa6 test.txt

# 将暂存区状态记录为树对象
$ git write-tree
3b5f84b1061eac2b4cf691b408f50e8c35ab4ebe

# 查看新生成的树对象结构
$ git cat-file -p 3b5f84b1061eac2b4cf691b408f50e8c35ab4ebe
100644 blob fa49b077972391ad58037050f2a75f74e3671e92    new.txt
100644 blob 088eda41aa61dc62fefef5d183a1f703bb01bfa6    test.txt
```

可以看到新生成的树对象包含两个数据对象(blob)，`test.txt`的SHA-1值为第二版本

**将第一个树对象加入第二个，使其成为新的树对象的子目录**

- `git read-tree --prefix=name SHA-1值` 将已有的树对象作为子树读入暂存区
  - `--prefix` 命名要加入的子树

```shell
# 将第一个树对象读入暂存区
$ git read-tree --prefix=newTree c89f1e026cabe89e7e80a139544a9ae5efc9b470

# 生成新的树对象
$ git write-tree
da0bde468d3a18d1d5a06107dffc8e10690b76b3

# 查看新的树对象的结构
$ git cat-file -p da0bde468d3a18d1d5a06107dffc8e10690b76b3
100644 blob fa49b077972391ad58037050f2a75f74e3671e92    new.txt
040000 tree c89f1e026cabe89e7e80a139544a9ae5efc9b470    newTree
100644 blob 088eda41aa61dc62fefef5d183a1f703bb01bfa6    test.txt
```

如果以最新的树对象生成工作目录，会有以下结构

![tree](tree.png)

#### 提交对象

现在有了三个对象，分别代表我们想要跟踪的不同项目快照。但是如果要重用这些快照，必须记住所有的SHA-1值，而且并不知道是谁保存了这些快照，在什么时候保存以及为什么保存。以上正是提交对象能保存的基本信息

**创建第一个树对象的提交对象**

- `git commit-tree SHA-值 [-p 该提交的父提交对象]`

```shell
# 创建第一个树对象的提交对象
$ echo 'first commit' | git commit-tree c89f1e026cabe89e7e80a139544a9ae5efc9b470
7f52240a2ad8cce875e24ebbfc49574f906f91bd

# 查看创建的提交对象
$ git cat-file -p 7f52240a2ad8cce875e24ebbfc49574f906f91bd
tree c89f1e026cabe89e7e80a139544a9ae5efc9b470
author TangBii <601098499@qq.com> 1575631531 +0800
committer TangBii <601098499@qq.com> 1575631531 +0800

first commit
```

提交对象的格式：

- 先指定一个顶层树对象，代表当前项目快照
- 作者和提交者信息外加一个时间戳
- 留空一行
- 提交注释

**再创建两个提交对象，分别以上一次提交作为其父对象**

```shell
# 创建第二个提交对象
$ echo 'second commit' | \
> git commit-tree 3b5f84b1061eac2b4cf691b408f50e8c35ab4ebe \
> -p 7f52240a2ad8cce875e24ebbfc49574f906f91bd
eb76b12e3c0e03fb4c36aa8155f50863adae7e69

# 创建第三个提交对象
$ echo 'third commit' | git commit-tree \
> da0bde468d3a18d1d5a06107dffc8e10690b76b3 \
> -p eb76b12e3c0e03fb4c36aa8155f50863adae7e69
741c463b7c6350aaaeafe0c1513bfde9c5fed17e
```

创建好的三个提交对象分别指向之前创建的三个树对象快照中的一个

**查看提交历史**

- `git log --stat 提交对象SHA-1` 查看提交历史

```shell
# 查看提交历史
$ git log --stat 741c463b7c6350aaaeafe0c1513bfde9c5fed17e
commit 741c463b7c6350aaaeafe0c1513bfde9c5fed17e
Author: TangBii <601098499@qq.com>
Date:   Fri Dec 6 20:10:15 2019 +0800

    third commit

 newTree/test.txt | 1 +
 1 file changed, 1 insertion(+)

commit eb76b12e3c0e03fb4c36aa8155f50863adae7e69
Author: TangBii <601098499@qq.com>
Date:   Fri Dec 6 20:06:46 2019 +0800

    second commit

 new.txt  | 1 +
 test.txt | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

commit 7f52240a2ad8cce875e24ebbfc49574f906f91bd
Author: TangBii <601098499@qq.com>
Date:   Fri Dec 6 19:25:31 2019 +0800

    first commit

 test.txt | 1 +
 1 file changed, 1 insertion(+)
```

#### 总结

至此，我们仅用几个底层操作便完成了一个Git历史的创建。这也是之后谈到的执行`git add`与‘git commit’命令时，Git所做的实质性工作：

- 将被改写的文件保存为数据对象
- 更新暂存区，记录树对象
- 创建一个指明了顶层树对象和父提交对象的提交对象

数据对象、树对象、提交对象都以单独的形式保存在`.git/objects`目录下，下面列出目前目录内的所有对象

```shell
$ find .git/objects -type f
.git/objects/08/8eda41aa61dc62fefef5d183a1f703bb01bfa6 # test.txt v2
.git/objects/3b/5f84b1061eac2b4cf691b408f50e8c35ab4ebe # tree 2
.git/objects/5b/dcfc19f119febc749eef9a9551bc335cb965e2 # test.txt v1
.git/objects/74/1c463b7c6350aaaeafe0c1513bfde9c5fed17e # commit 3
.git/objects/74/23c81faa8c815b6e8a1742fcc321d457cfaab0 # 'helloWorld'
.git/objects/7f/52240a2ad8cce875e24ebbfc49574f906f91bd # commit 1
.git/objects/c8/9f1e026cabe89e7e80a139544a9ae5efc9b470 # tree1
.git/objects/da/0bde468d3a18d1d5a06107dffc8e10690b76b3 # tree3
.git/objects/eb/76b12e3c0e03fb4c36aa8155f50863adae7e69 # commit 2
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
```

如果跟踪内部所有指针，将得到如下对象关系图：

<img src="structure.png" alt="图片1" style="zoom:50%;" />

