---

title: 糖文档-版本控制系统Git
date: 2019-11-28 17:46:06
catalog: true
toc-number: false
tags: [版本控制]
header-img: back.webp
header-color: rgb(65,57,50)
tag-color: rgb(65,57,50)
---



## 1. 前言

---

​	*注：糖文档是基于和官方文档同样完整但更加有趣易读的思想，在官方文档的基础上加以博主自己的理解而成的系列文档*

Git不能提高代码质量，但是可以让你大胆得去进行各种尝试

> Git —The stupid content tracker(傻瓜内容跟踪器)
>
> ——***Linus Benedict Torvalds***

 

## 2.  正文

---

### 2.1  版本控制

​	版本控制是对程序开发过程中各种程序，配置文件及说明文档等文件变更的管理。

​	主要作用是：

   - 快速便捷得回溯到项目过去某个时间点的状态，通俗点来说就是一键**ctrl+z**到想要回溯的版本
   - 并行开发

   

​	目前主要应用以SVN( subversion )为代表的集中式版本控制系统和以Git为代表的分布式版本控制系统

​	![集中式](2-1.webp)

![分布式](2-2.webp)

|      |                      集中式版本控制系统                      |                      分布式版本控制系统                      |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 优点 |   代码存放在单一服务器，便于项目管理<br />所需存储空间较少   | 版本控制在本地进行，对服务器的依赖小<br>版本控制时存放完整索引,回滚速度快<br />分支合并迅速，适合上千个分支的并行开发 |
| 缺点 | 对服务器稳定性要求较高，容易出现单点故障<br />每个版本存储的是差异，版本回滚速度慢 |                     所需存储空间较大<br>                     |

### 2.2   Git概述

#### 2.2.1  起源

​	Git是由*Linus Benedict Torvalds*开发的对于任意规模项目都快速有效的**开源免费**分布式版本控制系统。

​	当年~~Linux~~*Linus*创建了开源的Linux, 起初项目的管理维护工作都由手工完成，但是随着项目的不断扩大，绝大多数Linux内核的维护工作都花费在了这些重复且枯燥的事务上。到了2002年，商业版本控制软件BitKeeper授权整个项目组基于一定协议免费使用，但是Linux项目的大牛们觉得商业软件不符合开源共享的思想，就在社区内把这款收费软件破解了，这使得开发BitKeeper的公司不再授权免费使用。*Linux*想这么大的项目不能没有自动化的版本控制，但是使用商业软件又被限制住了腿脚，不如自己写一个。不多久，他们就写出了一个设计更简单但是速度更快操作更简易的版本控制系统也就是Git。并且开放了Git的源代码，每个人每个公司都可以免费使用。自诞生自2005年，Git发展迅速，现在已成为各大公司首选的版本控制系统

#### 2.2.2 特性

**直接记录快照，而非差异比较**

![集中式与分布式回滚对比](2-3.png)

Git对待数据更像是快照流。 每次你提交更新或在 Git 中保存项目状态时，它会对当时的全部文件制作一个快照并保存这个快照的索引。

**近乎所有操作都在本地执行**

 因为每个用户都保存着项目的完整记录， 所以在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息 。这不仅意味着超凡的速度，也意味着即使离线或者没有VPN也几乎可以进行任何操作。

**保证数据完整性**

Git使用校验和确保数据每一比特的完整性。Git中所有数据在存储前都计算校验和，然后以校验和来引用。无论以何种方式都不可能在Git不知情时更改任何文件内容或目录内容，如果在传送中丢失信息或损坏文件，Git也能发现。

**分支模型**

Git的分支模型是它区分于其他版本控制系统的主要特征。GIt鼓励我们拥有多个独立的本地分支，创建、合并或者删除这些分支都只需要几秒钟的时间。

分支可以用来：

- **无忧实验**  创建一个分支用来尝试新点子或者应用一个补丁，如果有效，将他们合并到主分支即可，如果无效，也可以方便得回溯到项目之前状态，所以大胆去尝试你的新点子吧!

- **多分支协同工作** 一个应用于生产环境的分支，一个用来合并测试的分支和其他一些用来日常工作（比如改bug的小分支）<br><img src="branches@2x.png" alt="branches" style="zoom:50%;" />
- **分支测试** 为每一个新特性创建一个新分支，测试完毕合并到主分支后删除

总的来说，分支不仅可以让你解除测试的后顾之忧从而更加关注于新特性本身，还可以让你自由得与团队伙伴们分享创意而无需考虑何时去合并这些特性。GIt会彻底得改变我们的工作方式，无论是个人开发还是团队合作

**体积小速度快**

Git几乎所有的操作都在本地执行，这使得它和必须依赖与服务器不断通信的集中式版本控制系统相比有巨大的速度优势。GIt是为Linux内核的工作而创建的，这意味着从第一天开始它就必须能够应对大型存储库。GIt是用C编写的（~~C语言是最好的语言，总有一天我会精通它~~），减少了使用高级语言的运行时开销。

下面我们来看一下GIt和SVN在相同环境下执行命令所需时间的对比([数据来源]( https://git-scm.com/about/small-and-fast ))

| Operation         |                                                             | Git  |  SVN   |      |
| ----------------- | ----------------------------------------------------------- | :--: | :----: | ---- |
| Commit Files (A)  | Add, commit and push 113 modified files (2164+, 2259-)      | 0.64 |  2.60  | 4x   |
| Commit Images (B) | Add, commit and push 1000 1k images                         | 1.53 | 24.70  | 16x  |
| Diff Current      | Diff 187 changed files (1664+, 4859-) against last commit   | 0.25 |  1.09  | 4x   |
| Diff Recent       | Diff against 4 commits back (269 changed/3609+,6898-)       | 0.25 |  3.99  | 16x  |
| Diff Tags         | Diff two tags against each other (v1.9.1.0/v1.9.3.0 )       | 1.17 | 83.57  | 71x  |
| Log (50)          | Log of the last 50 commits (19k of output)                  | 0.01 |  0.38  | 31x  |
| Log (All)         | Log of all commits (26,056 commits - 9.4M of output)        | 0.52 | 169.20 | 325x |
| Log (File)        | Log of the history of a single file (array.c - 483 revs)    | 0.60 | 82.84  | 138x |
| Update            | Pull of Commit A scenario (113 files changed, 2164+, 2259-) | 0.90 |  2.82  | 3x   |
| Blame             | Line annotation of a single file (array.c)                  | 1.91 |  3.04  | 1x   |

可以看到Git完胜SVN。这还是在SVN无负载，与客户端计算机带宽连接为80MB/s的情况下。如果连接速度变慢，SVN会变得更慢，但是Git的很多时间并不会受到影响(因为是在本地执行)

我们再来看看双方的克隆操作和存储对比

| Operation |                                                              | Git* |  Git  |  SVN  |
| --------- | ------------------------------------------------------------ | :--: | :---: | :---: |
| Clone     | Clone and shallow clone(*) in Git vs checkout in SVN         | 21.0 | 107.5 | 14.0  |
| Size (M)  | Size of total client side data and files after clone/checkout (in M) |      | 181.0 | 132.0 |

Git中一个较慢的操作是初始克隆，它克隆了项目的整个历史纪录，而不仅仅是最新版本。对于仅克隆最新版本的操作（GIt*）而言，速度并没有显著降低(21.0对14.0)

另一个有趣的事实是，即使Git存储着项目的完整记录，它的体积相对于只存储最新版本的SVN来比也相差不大。这体现了GIt高效的压缩和存储效率。

**分布式**

GIt是一个分布式的版本控制系统，这意味着每个终端都保存着项目的完整历史记录（基于高效压缩，我们不需担心它的体积过大），但是这有什么好处呢？

- 多个备份<br>即使我们使用集中式的工作流(这与分布式版本控制并不冲突)，每个用户也都有主服务器的完整历史记录，即使主服务器宕机，也可以从任意用户恢复，这避免了单点故障,除非只有一个用户且这个用户同时充当主服务器。

- 任意规模<br>由于Git的分布式特性和出色的分支系统，可以相对轻松得实现近乎无限数量的工作流

- 任意形式的工作流<br>*[注:工作流指 业务过程的部分或整体在计算机应用环境下的自动化”，可简单理解为工作过程和工作规则] *

  - 颠覆式工作流(Subversion-Style Workflow)<br>在你提交(push)代码时，如果有团队成员已经提交了代码，则你必须先获取(fetch)别人提交的代码才能提交。<br>![颠覆式工作流](2-4.png)
  - 集成管理工作流(Integration Manager Workflow)<br>集成管理员管理一个集成仓库，开发者从集成仓库克隆代码到本地库，在本地开发后把代码推送到自己的独立存储库并要求集成管理员提取这些更改合并到集成仓库<br>![集成管理工作流](2-5.png)
  - 独裁者和中尉工作流(Dictator and Lieutenants Workflow)<br>适用于更大规模的项目。”独裁者“合并”中尉“提交的代码到集成仓库，”中尉“合并自己所管项目参与者提交的代码。每个参与者都可以从集成仓库克隆代码到本地<br>![独裁者和中尉工作流](2-6.png)


### 2.3 git 起步

