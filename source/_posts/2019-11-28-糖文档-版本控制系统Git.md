title: 糖文档-版本控制系统Git
date: 2019-11-28 17:46:06
catalog: true
toc-number: false
tags: [版本控制]
header-img: back.webp
header-color: rgb(65,57,50)
tag-color: rgb(65,57,50)

---



**<font size=6>前言</font>**

---

*注：糖文档是基于和官方文档同样完整但更加有趣易读的思想，在官方文档的基础上加以博主自己的理解而成的系列文档*

Git不能提高代码质量，但是可以让你大胆得去进行各种尝试

> Git —The stupid content tracker(傻瓜内容跟踪器)
>
> ——***Linus Benedict Torvalds***

**<font size=6>正文</font>**

---

## 1. 版本控制

​	版本控制是对程序开发过程中各种程序，配置文件及说明文档等文件变更的管理。

​	主要作用是：

   - 快速便捷得回溯到项目过去某个时间点的状态，通俗点来说就是一键**ctrl+z**到想要回溯的版本
   - 并行开发

​	目前主要应用以SVN( subversion )为代表的集中式版本控制系统和以Git为代表的分布式版本控制系统

​	![集中式](2-1.webp)

![分布式](2-2.webp)

|      |                      集中式版本控制系统                      |                      分布式版本控制系统                      |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 优点 |   代码存放在单一服务器，便于项目管理<br />所需存储空间较少   | 版本控制在本地进行，对服务器的依赖小<br>版本控制时存放完整索引,回滚速度快<br />分支合并迅速，适合上千个分支的并行开发 |
| 缺点 | 对服务器稳定性要求较高，容易出现单点故障<br />每个版本存储的是差异，版本回滚速度慢 |                     所需存储空间较大<br>                     |

## 2 . Git概述

### 2.1 起源

​	Git是由*Linus Benedict Torvalds*开发的对于任意规模项目都快速有效的开源免费**分布式版本控制系统**。

​	当年~~Linux~~*Linus*创建了开源的Linux, 起初项目的管理维护工作都由手工完成，但是随着项目的不断扩大，绝大多数Linux内核的维护工作都花费在了这些重复且枯燥的事务上。到了2002年，商业版本控制软件BitKeeper授权整个项目组基于一定协议免费使用，但是Linux项目的大牛们觉得商业软件不符合开源共享的思想，就在社区内破解了这款软件，这使得开发BitKeeper的公司不再授权免费使用。*Linus*想这么大的项目不能没有自动化的版本控制，但是使用商业软件又被限制住了腿脚，不如自己写一个。不多久，他们就写出了一个设计更简单但是速度更快操作更简易的版本控制系统Git，并且开放了Git的源代码，每个人每个公司都可以免费使用。自诞生自2005年，Git发展迅速，现在已成为各大公司首选的版本控制系统

### 2.2 特性

**直接记录快照，而非差异比较**

![集中式与分布式回滚对比](2-3.png)

Git对待数据更像是快照流。 每次你提交更新或在 Git 中保存项目状态时，它会对当时的全部文件制作一个快照并保存这个快照的索引。

**近乎所有操作都在本地执行**

 因为每个用户都保存着项目的完整记录， 所以在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息 。这不仅意味着超凡的速度，也意味着即使离线或者没有VPN也可以继续工作。

**保证数据完整**

Git使用校验和确保数据每一比特的完整性。Git中所有数据在存储前都计算校验和，然后以校验和来引用。无论以何种方式都不可能在Git不知情时更改任何文件内容或目录内容，如果在传送中丢失信息或损坏文件，Git也能发现。

**分支**

Git的分支模型是它区分于其他版本控制系统的主要特征。Git建议我们拥有多个独立的本地分支，创建、合并或者删除这些分支都只需要几秒钟的时间。Git会彻底得改变我们的工作方式，无论是个人开发还是团队合作

分支可以用来：

- **无忧实验**  创建一个分支用来尝试新点子或者应用一个补丁，如果有效，将他们合并到主分支即可，如果无效，也可以方便得回溯到项目之前状态，大胆去尝试你的新点子吧!

- **多分支协同工作** 一个应用于生产环境的分支，一个用来合并测试的分支和其他一些用来日常工作（比如改bug的小分支）<br><img src="branches@2x.png" alt="branches" style="zoom:50%;" />
- **分支测试** 为每一个新特性创建一个新分支，测试完毕合并到主分支后删除

**体积小速度快**

Git几乎所有的操作都在本地执行，这使得它和必须依赖与服务器不断通信的集中式版本控制系统相比有巨大的速度优势。Git是为Linux内核的工作而创建的，这意味着从第一天开始它就必须能够应对大型存储库。Git是用C编写的（~~C语言是最好的语言，总有一天我会精通它~~），减少了使用高级语言的运行时开销。

**分布式**

Git是一个分布式的版本控制系统，这意味着每个终端都保存着项目的完整历史记录（基于高效压缩，我们不需担心它的体积过大），但是这有什么好处呢？

- 多个备份<br>

- 任意规模<br>由于Git的分布式特性和出色的分支系统，可以相对轻松得实现近乎无限数量的工作流

- 任意形式的工作流<br>*[注:工作流指 业务过程的部分或整体在计算机应用环境下的自动化”，可简单理解为工作过程和工作规则] *

  - 颠覆式工作流(Subversion-Style Workflow)<br>在你提交(push)代码时，如果有团队成员已经提交了代码，则你必须先获取(fetch)别人提交的代码才能提交。<br>![颠覆式工作流](2-4.png)
  - 集成管理工作流(Integration Manager Workflow)<br>集成管理员管理一个集成仓库，开发者从集成仓库克隆代码到本地库，在本地开发后把代码推送到自己的独立存储库并要求集成管理员提取这些更改合并到集成仓库<br>![集成管理工作流](2-5.png)
  - 独裁者和中尉工作流(Dictator and Lieutenants Workflow)<br>适用于更大规模的项目。”独裁者“合并”中尉“提交的代码到集成仓库，”中尉“合并自己所管项目参与者提交的代码。每个参与者都可以从集成仓库克隆代码到本地<br>![独裁者和中尉工作流](2-6.png)

## 3. 重要概念

### 3.1 三个工作区域

- **工作目录**

  工作目录是对项目的某个版本独立提取出来放在磁盘上供使用和修改的内容

- **暂存区域（索引）**

  暂存区是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中

- **Git仓库**

  Git仓库是保存项目数据和历史版本的地方，是Git中最重要的部分
  
  <img src="areas.png" alt="areas" style="zoom: 50%;" />

### **3.2 <span id='jump'>文件生命周期</span>**

工作目录下面的所有文件都只有两种身份:`未跟踪`、`已跟踪`

`已跟踪的文件`是指那些被纳入版本控制的文件，在上一次快照中有他们的记录。工作目录中除已跟踪文件外的所有文件都为`未跟踪文件`，他们既不存在于上次快照的记录中，也没有放入暂存区

- **已提交(committed)**

  已提交表示数据已安全得保存在Git仓库中

- **已修改(modified)**

  已修改表示文件在工作目录做了修改，但是尚未暂存

- **已暂存(staged)**

  已暂存表示下次提交的快照中会包含这个文件

<img src="state.png" alt="state" style="zoom: 67%;" />

### 3.3 **基本工作流程**

- 在工作目录中修改文件
- 暂存文件，将文件快照放到暂存区
- 提交更新，找到暂存区文件，将快照永久性存储到Git仓库

## 4. Git内部原理

学习这部分对理解Git的用途和强大至关重要，但对于初学者来说可能有点难于理解。在学习过程中可以先学习这一部分也可以最后再学习这一部分。本节主要面对底层命令，它有助于说明Git是如何完成工作的。如果只是简单使用Git，不需要记住这些命令。

### 4.1 目录结构

<img src="catalog.png" alt="图片1" style="zoom: 50%;" />

创建暂存区后还会生成`index 文件`保存暂存区信息。

在这一节我们重点讨论: `objects目录`、`refs目录`、`HEAD文件`和`(待创建的)index文件`

### 4.2 Git对象

#### 数据对象

Git核心部分是一个简单的键值对数据库。可以向数据库插入任何内容，它会返回一个键值，通过该键值可以在任意时刻重新检索该内容。下面通过底层命令`hash-object`来演示。

**初始化Git仓库，并存入一些数据**

- `hash-object -w --stdin` 向数据库插入内容
  - `-w` 指示该命令存储数据对象，如果不指定该选项,命令仅返回对应的键值
  - `--stdin` 指示该命令从标准输入读取内容，如果不指定该选项，需要在命令尾部加上待存储文件路径

```shell
# 初始化Git仓库
$ git init	
Initialized empty Git repository in C:/Users/Administrator/Desktop/test/.git/

# Git对objects目录进行了初始化，并创建了空的info和pack目录
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack

#存入值为"helloWorld"的数据
$ echo 'helloWorld' | git hash-object -w --stdin  
7423c81faa8c815b6e8a1742fcc321d457cfaab0 
```

存储命令输出一个由*待存储信息*外加一个*头部信息*一起做SHA-1校验运算得到的校验和`7423c81faa8c815b6e8a1742fcc321d457cfaab0`

**查看Git如何存储数据**

```shell
# 查看Git如何存储数据
$ find .git/objects -type f 
.git/objects/74/23c81faa8c815b6e8a1742fcc321d457cfaab0
```

刚才存储的数据对应了一条内容。校验和的前两个字符用于命名子目录*74/*，剩下的38个字符作为文件名`23c81faa8c815b6e8a1742fcc321d457cfaab0`

**从Git取出数据**

- `git cat-file -p SHA-1值` 从Git取出数据
  - `-p`指示该命令自动判断内容类型，并显示格式友好内容

```shell
# 从Git取出数据
$ git cat-file -p 7423c81faa8c815b6e8a1742fcc321d457cfaab0
helloWorld
```

**查看数据类型**

- `git cat-file -t SHA-1值` 返回存储的对象类型

```shell
# 查看数据类型
$ git cat-file -t 7423c81faa8c815b6e8a1742fcc321d457cfaab0 
blob
```

给定对象的SHA-1值，可以获取Git内部存储的任何对象类型，可以看到此处存储的为`数据对象(blob object)`类型

以上演示了往Git中存入数据和取出数据，这些操作也可以作用于文件内容，接下来对文件进行一个简单的版本控制

**创建一个新文件，并将其存入数据库**

```shell
# 创建新文件
$ echo 'version1' > test.txt

# 存入数据库
$ git hash-object -w test.txt
5bdcfc19f119febc749eef9a9551bc335cb965e2
```

**向文件内写入新内容，并存入数据库**

```shell
# 向文件内写入新内容
$ echo 'version' > test.txt

# 存入数据库
$ git hash-object -w test.txt
088eda41aa61dc62fefef5d183a1f703bb01bfa6
```

**查看数据库内容**

```shell
# 查看数据库内容
$ find .git/objects -type f
.git/objects/08/8eda41aa61dc62fefef5d183a1f703bb01bfa6 # 第二次创建文件的第二个版本
.git/objects/5b/dcfc19f119febc749eef9a9551bc335cb965e2 # 第二次创建文件的第一个版本
.git/objects/74/23c81faa8c815b6e8a1742fcc321d457cfaab0 # 第一次创建的文件
```

**恢复文件内容到第一个版本**

```shell
# 恢复文件内容到第一个版本
$ git cat-file -p 5bdcfc19f119febc749eef9a9551bc335cb965e2 > test.txt

# 查看恢复后文件内容
$ cat test.txt
version1
```

**恢复文件内容到第二个版本**

```shell
# 恢复文件内容到第二个版本
$ git cat-file -p 088eda41aa61dc62fefef5d183a1f703bb01bfa6 > test.txt

# 查看恢复后文件内容
$ cat test.txt
version
```

**对应的高层命令**

```shell
# 初始化
$ git init
Initialized empty Git repository in C:/Users/Administrator/Desktop/新建文件夹/.git/
$ echo 'niceCommand' > nice.txt

# 将文件加入暂存区
$ git add nice.txt
warning: LF will be replaced by CRLF in nice.txt.
The file will have its original line endings in your working directory

# 查看
$ find .git/objects -type f
.git/objects/5b/49cc806c7a41c25d152f69ac20a504a61d8037
```

可以看到，将待跟踪文件加入暂存区时会将其存储到`.git/objects`下对应的子目录中,本例为`.git/objects/5b/49cc806c7a41c25d152f69ac20a504a61d8037`

#### 树对象

数据对象并没有保存文件名，只保存了文件的内容。树对象可以解决文件名的保存问题，也允许我们将多个文件组织到一起

一个树对象包含一条或多条树对象记录，每条记录含有一个指向数据对象或者子树对象的SHA-1指针以及相应的模式、类型、文件名信息。(类似于windows的文件夹，文件夹可以再包含文件或者文件夹)

**创建树对象**

通常，Git通过某一时刻暂存区(即index区域)所表示的状态创建并记录一个对应的树对象。因此，为创建一个树对象，首先需通过暂存一些文件创建一个暂存区

- `git update-index --add --cacheinfo 100644 SHA-1值 文件名` 将一个文件存入暂存区
  - `--add`	如果此文件不在暂存区，则应该指定该选项
  - `--cacheinfo` 如果将添加的文件位于Git数据库而不是当前目录(即先前版本)，应指定该选项
  - `100644` 表示普通文件的文件模式，其他包括：`100775`可执行文件、`120000`符号链接
- `write-tree` 将暂存区内容写入树对象。无需指定`-w`选项，如果某个树对象此前不存在会自动创建

```shell
# 将test第一个版本存入暂存区
git update-index --add --cacheinfo 100644 \
> 5bdcfc19f119febc749eef9a9551bc335cb965e2 test.txt

# 将暂存区内容写入树对象
$ git write-tree 5bdcfc19f119febc749eef9a9551bc335cb965e2
c89f1e026cabe89e7e80a139544a9ae5efc9b470

# 查看新生成到树对象的内容
$ git cat-file -p c89f1e026cabe89e7e80a139544a9ae5efc9b470
100644 blob 5bdcfc19f119febc749eef9a9551bc335cb965e2    test.txt

# 验证新生成的树对象类型
$ git cat-file -t c89f1e026cabe89e7e80a139544a9ae5efc9b470
tree
```

**再创建一个包括`test.txt`文件第二个版本和一个新文件的树对象**

```shell
# 生成新文件
$ echo 'new file' > new.txt

# 将新文件加入暂存区
$ git update-index --add new.txt

# 将test.txt的第二个版本加入暂存区
$ git update-index --add --cacheinfo 10064 \    # "\"表示换行
> 088eda41aa61dc62fefef5d183a1f703bb01bfa6 test.txt

# 将暂存区状态记录为树对象
$ git write-tree
3b5f84b1061eac2b4cf691b408f50e8c35ab4ebe

# 查看新生成的树对象结构
$ git cat-file -p 3b5f84b1061eac2b4cf691b408f50e8c35ab4ebe
100644 blob fa49b077972391ad58037050f2a75f74e3671e92    new.txt
100644 blob 088eda41aa61dc62fefef5d183a1f703bb01bfa6    test.txt
```

可以看到新生成的树对象包含两个数据对象(blob)，`test.txt`的SHA-1值为第二版本

**将第一个树对象加入第二个，使其成为新的树对象的子目录**

- `git read-tree --prefix=name SHA-1值` 将已有的树对象作为子树读入暂存区
  - `--prefix` 命名要加入的子树

```shell
# 将第一个树对象读入暂存区
$ git read-tree --prefix=newTree c89f1e026cabe89e7e80a139544a9ae5efc9b470

# 生成新的树对象
$ git write-tree
da0bde468d3a18d1d5a06107dffc8e10690b76b3

# 查看新的树对象的结构
$ git cat-file -p da0bde468d3a18d1d5a06107dffc8e10690b76b3
100644 blob fa49b077972391ad58037050f2a75f74e3671e92    new.txt
040000 tree c89f1e026cabe89e7e80a139544a9ae5efc9b470    newTree
100644 blob 088eda41aa61dc62fefef5d183a1f703bb01bfa6    test.txt
```

如果以最新的树对象生成工作目录，会有以下结构

![tree](tree.png)

#### 提交对象

现在有了三个对象，分别代表我们想要跟踪的不同项目快照。但是如果要重用这些快照，必须记住所有的SHA-1值，而且并不知道是谁保存了这些快照，在什么时候保存以及为什么保存。以上正是提交对象能保存的基本信息

**创建第一个树对象的提交对象**

- `git commit-tree SHA-值 [-p 该提交的父提交对象]`

```shell
# 创建第一个树对象的提交对象
$ echo 'first commit' | git commit-tree c89f1e026cabe89e7e80a139544a9ae5efc9b470
7f52240a2ad8cce875e24ebbfc49574f906f91bd

# 查看创建的提交对象
$ git cat-file -p 7f52240a2ad8cce875e24ebbfc49574f906f91bd
tree c89f1e026cabe89e7e80a139544a9ae5efc9b470
author TangBii <601098499@qq.com> 1575631531 +0800
committer TangBii <601098499@qq.com> 1575631531 +0800

first commit
```

提交对象的格式：

- 先指定一个顶层树对象，代表当前项目快照
- 作者和提交者信息外加一个时间戳
- 留空一行
- 提交注释

**再创建两个提交对象，分别以上一次提交作为其父对象**

```shell
# 创建第二个提交对象
$ echo 'second commit' | \
> git commit-tree 3b5f84b1061eac2b4cf691b408f50e8c35ab4ebe \
> -p 7f52240a2ad8cce875e24ebbfc49574f906f91bd
eb76b12e3c0e03fb4c36aa8155f50863adae7e69

# 创建第三个提交对象
$ echo 'third commit' | git commit-tree \
> da0bde468d3a18d1d5a06107dffc8e10690b76b3 \
> -p eb76b12e3c0e03fb4c36aa8155f50863adae7e69
741c463b7c6350aaaeafe0c1513bfde9c5fed17e
```

创建好的三个提交对象分别指向之前创建的三个树对象快照中的一个

**查看提交历史**

- `git log --stat 提交对象SHA-1` 查看提交历史

```shell
# 查看提交历史
$ git log --stat 741c463b7c6350aaaeafe0c1513bfde9c5fed17e
commit 741c463b7c6350aaaeafe0c1513bfde9c5fed17e
Author: TangBii <601098499@qq.com>
Date:   Fri Dec 6 20:10:15 2019 +0800

    third commit

 newTree/test.txt | 1 +
 1 file changed, 1 insertion(+)

commit eb76b12e3c0e03fb4c36aa8155f50863adae7e69
Author: TangBii <601098499@qq.com>
Date:   Fri Dec 6 20:06:46 2019 +0800

    second commit

 new.txt  | 1 +
 test.txt | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

commit 7f52240a2ad8cce875e24ebbfc49574f906f91bd
Author: TangBii <601098499@qq.com>
Date:   Fri Dec 6 19:25:31 2019 +0800

    first commit

 test.txt | 1 +
 1 file changed, 1 insertion(+)
```

#### 总结

至此，我们仅用几个底层操作便完成了一个Git历史的创建。这也是之后谈到的执行`git add`与‘git commit’命令时，Git所做的实质性工作：

- 将被改写的文件保存为数据对象
- 更新暂存区，记录树对象
- 创建一个指明了顶层树对象和父提交对象的提交对象

数据对象、树对象、提交对象都以单独的形式保存在`.git/objects`目录下，下面列出目前目录内的所有对象

```shell
$ find .git/objects -type f
.git/objects/08/8eda41aa61dc62fefef5d183a1f703bb01bfa6 # test.txt v2
.git/objects/3b/5f84b1061eac2b4cf691b408f50e8c35ab4ebe # tree 2
.git/objects/5b/dcfc19f119febc749eef9a9551bc335cb965e2 # test.txt v1
.git/objects/74/1c463b7c6350aaaeafe0c1513bfde9c5fed17e # commit 3
.git/objects/74/23c81faa8c815b6e8a1742fcc321d457cfaab0 # 'helloWorld'
.git/objects/7f/52240a2ad8cce875e24ebbfc49574f906f91bd # commit 1
.git/objects/c8/9f1e026cabe89e7e80a139544a9ae5efc9b470 # tree1
.git/objects/da/0bde468d3a18d1d5a06107dffc8e10690b76b3 # tree3
.git/objects/eb/76b12e3c0e03fb4c36aa8155f50863adae7e69 # commit 2
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
```

如果跟踪内部所有指针，将得到如下对象关系图：

<img src="structure.png" alt="图片1" style="zoom:50%;" />

## **5. Git初始化**

### 5.1 配置用户信息

在系统中安装Git后，可通过以下方法定制Git环境。每台计算机只需配置一次，并可在任何时候通过命令修改。

配置变量存储在三个不同位置(括号内为Windows系统路径)：

- `/etc/gitconfig(Git\mingw64\etc\gitconfig)`

  系统上所有用户的通用配置，`git config 	--system`从此文件读写配置变量

- `~/.gitconfig`或`~/.config/git/config(C:\Users\$User\.gitconfig)`

  只针对当前用户，`git  config --global`从此文件读写配置变量

- 当前仓库目录下的config文件

  针对该仓库

每个级别配置会覆盖上一级别配置，例如`.git/config`会覆盖`~/.gitconfig`与`/etc/gitconfig`中的配置变量

团队协同开发时需要辨认代码段是由哪个成员提交的，所以安装完Git后的第一件事是设置你的用户名和邮箱地址。它会被写入到每一次Git提交，并且写入的信息不可更改。

- **配置全局用户信息**

  - `$ git config --system user.name ${name}`

  - `$ git config --system user.email ${email}`

  ```shell
  # 配置全局用户信息
  $ git config --system user.name "TangBii_system"
  $ git config --system user.email "601098499@qq.com_system"
  
  # 查看
  $ cd Git/mingw64/etc
  $ cat gitconfig
  [user]
          name = TangBii_system
          email = 601098499@qq.com_system
  ```

- **配置当前用户信息**

  - `$ git config --global user.name ${name}`
  - `$ git config --global user.email ${email}`

  ```shell
  # 配置当前用户信息
  $ git config --global user.name 'TangBii_global'
  $ git config --global user.email '601098499@qq.com_global'
  
  # 查看
  $ cat .gitconfig
  [user]
          name = TangBii_global
          email = 601098499@qq.com_global
  ```

- **配置项目用户信息**

  - `$ git config user.name ${name}`
  - `$ git config user.email ${email}`
  
  ```shell
  # 配置当前项目用户信息
  $ git config user.name 'TangBii_project'
  $ git config user.email '601098499@qq.com_project'
  
  # 查看
  $ cd .git/
  $ cat config
  [user]
          name = TangBii_project
          email = 601098499@qq.com_project
  ```

### **5.2 配置默认文本编辑器**

```shell
# 配置默认文本编辑器
git config --global core.editor \
> "'要配置的编辑器的路径' \
> -multiInst -notabbar -nosession -noPlugin '$*'"
```

### 5.3查看配置信息

- `git config --list` 查看Git所有配置

- `git config <key>` 查看Git应用的某一项配置

Git会从不同文件中读取同一个配置，所以可能会看到重复的变量名，Git使用找到的每个变量的最后一个配置

```shell
# 查看所有配置
$ git config --list
...
user.name=TangBii_system
user.email=601098499@qq.com_system
...
user.name=TangBii_global
user.email=601098499@qq.com_global
...
user.name=TangBii_project
user.email=Ta601098499@qq.com_project

# 查看应用的user.name
$ git config user.name
TangBii_project

# 查看应用的user.email
$ git config user.email
601098499@qq.com_project
```

## 6. Git基本操作

### 6.1 获取Git仓库

可以从本地项目导入，也可以从服务器克隆一个现有的Git仓库。

#### **本地项目导入**

- **`git init` 创建Git仓库**

  在项目目录下使用该命令会创建一个包含Git仓库骨干文件的.git目录。但此时仅仅做了初始化操作，项目内的文件还处于`未跟踪`状态，可使用`git add`跟踪文件，`git commit`提交，这两个命令会在之后介绍。

```shell
# 创建仓库
$ git init
Initialized empty Git repository in test1/.git/

# 将test.txt加入跟踪
$ git add test.txt

# 提交
$ git commit -m 'initial'
[master (root-commit) 100b311] initial
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 test.txt
```

#### **从服务器克隆**

- `git clone [url] [name]` 克隆现有的仓库

  - 可以在`url`之后加自定义名称指定本地仓库的名称

  执行该命令时，默认配置下远程Git仓库中的每一个文件每一个版本都被将被拉取下来，也就是说可以用任意一个克隆下的客户端重建服务器上的仓库

```shell
# 克隆远程仓库
$ git clone https://github.com/TangBii/remoteRepository.git
Cloning into 'remoteRepository'...

# 克隆远程仓库并自定义为myRepository
$ git clone https://github.com/TangBii/remoteRepository.git myRepository
Cloning into 'myRepository'...
```

上述操作会在本地创建一个名为`remoteRepository/myRepository`的目录，并在该目录下初始化一个`.git`文件夹，从远程仓库拉取所有数据放入.git文件夹，然后从中读取最新版本的文件的拷贝放入工作目录

### 6.2  记录版本更新

现在我们手上有了一个完整的Git仓库，并从这个仓库取出了所有文件的工作拷贝。接下来对这些文件做一些修改，在完成一个阶段的目标后，用Git记录

初次克隆某个仓库的时候，工作目录的所有文件都属于`已跟踪`文件，并处于`未修改`状态。如果不太了解这些状态，可以复习[文件生命周期](#jump)

#### **检查当前文件状态**

- `git status` 检查当前文件状态
  - `-s` [紧凑形式的输出](#small)

```shell
# 检查当前文件状态
$ git status
On branch master # 处在master分支

No commits yet # 没有新的提交

nothing to commit (create/copy files and use "git add" to track) # 暂存区为空
```

如果克隆仓库后立即使用该命令会看到类似于以上的输出。这表示当前的工作目录非常干净，也就是说：

- 已跟踪的文件在上一次提交后没有发生变化
- 当前目录下不存在未跟踪的文件

同时`On branch master`表明当前处在`master`分支。

#### **跟踪新文件**

接下来我们创建一个新的`README`文件，并跟踪它

- `git add 文件或目录路径` 
  - 该命令有多个功能:
    - 跟踪新文件
    - 把已跟踪的文件放到暂存区
    - 合并时把冲突文件标记为以解决
  - 如果参数是目录路径，递归跟踪该目录下所有文件(`git add . `跟踪当前目录所有文件)

```shell
# 创建新的README.md文件
$ echo newFile > README.md

# 查看当前文件的状态
$ git status
On branch master 

No commits yet 

Untracked files:  # 以下为未跟踪的文件
  (use "git add <file>..." to include in what will be committed)

        README.md

nothing added to commit but untracked files present (use "git add" to track)

# 跟踪 README.md
$ git add README.md

# 查看文件状态
$ git status
On branch master

No commits yet

Changes to be committed:  # 以下为已暂存的文件
  (use "git rm --cached <file>..." to unstage)

        new file:   README.md

```

#### **暂存已修改文件**

```shell
# 修改已跟踪的trackedFile文件
$ echo 'trackedFile v2' > trackedFile

# 查看文件状态
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        new file:   README.md

Changes not staged for commit:  # 已跟踪内容发生变化但没放到暂存区
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   trackedFile
        
# 将trackedFile加入暂存区        
$ git add trackedFile

# 查看文件状态
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        new file:   README.md
        modified:   trackedFile
```

#### **再次修改trackedFile**

```shell
# 再次修改trackedFile
$ echo 'trackedFile v2 new' > trackedFile

# 查看文件状态
$ git status
On branch master

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        new file:   README.md
        modified:   trackedFile

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   trackedFile

```

我们看到`trackedFile`同时出现在了`暂存区`和`非暂存区`。这是因为实际上Git只暂存了运行`git add`时的版本，如果此时提交，`trackedFile`的版本会是最后一次运行`git add`命令的版本(‘trackedFile v2’)，而不是当前工作目录的版本(‘trackedFile v2 new’)。所以运行了`git add`后又做了改变的版本需要重新运行`git add`将最新版本暂存起来。

```shell
# 暂存当前工作目录的最新版本
$ git add trackedFile

# 查看文件状态 
$ git status
On branch master
Your branch is based on 'origin/master', but the upstream is gone.
  (use "git branch --unset-upstream" to fixup)

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        new file:   README.md
        modified:   trackedFile
```

#### **查看已暂存和未暂存的修改**

- `git diff` 展示具体修改了哪些地方
  - 不加参数表示比较工作目录中文件与暂存区文件，即修改后还没暂存起来的变化内容
  - `--cached/--staged` 查看已暂存的将要添加到下次提交的内容

```shell
# 修改README.md并加入暂存区
$ echo 'readme v3' > README.md
$ git add README.md

# 修改trackedFile，但不加入暂存区
$ echo 'trackedFile v3' > trackedFile

# 修改后还没暂存起来的变化内容
$ git diff
diff --git a/trackedFile b/trackedFile
index e185352..b9b6d78 100644
--- a/trackedFile
+++ b/trackedFile
@@ -1 +1 @@
-trackedFile v2 new
+trackedFile v3

# 将要添加到下次提交的内容 
$ git diff --staged
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..b31eb96
--- /dev/null
+++ b/README.md
@@ -0,0 +1 @@
+readme v3
```

#### **提交更新**

- `git commmit -m [message]` 提交暂存区文件状态
  - 如果不加`-m`会进入到默认编辑器输入本次提交的说明
  - `-a` 跳过暂存区，直接提交所有`已跟踪`文件

```shell
$ git commit -m 'myFirstCommit'
[master 4bc256a] myFirstCommit  # 在master分支提交，校验和4bc256a
 2 files changed, 2 insertions(+), 1 deletion(-) # 2个文件变化，新添加2行，删除1行
 create mode 100644 README.md
```

#### **拓展**

- **<span id='small'>查看简述的文件状态</span>**

  - `git status -s` 紧凑形式的输出
    - `A` 新添加到暂存区的文件
    - `右M`修改了但是还没放入暂存区
    - `左M` 修改了并放入了暂存区
    - `？？` 新添加的未跟踪文件

  ```shell
  $ git status -s
  A  git.rb # 新添加到暂存区
   M README  # 在工作目录修改了但是没加入暂存区
  M  simplegit.rb # # 在工作目录修改了并将修改后的文件加入了暂存区
  MM Rakefile # 在工作目录修改并加入暂存区后又在工作目录修改了并且未加入暂存区
  ?? LICENSE.txt # 新添加的未跟踪文件
  ```

- **移除文件**

  在Git中删除一个文件，不仅要在工作目录中删除该文件，而且还要在暂存区记录删除，下一次提交时，该文件就不再纳入版本管理了。如果直接删除文件需要手动再将删除行为记录到暂存区。

  - `git rm 文件`  删除文件并将删除操作记录到暂存区
    - `-f` 如果删除之前修改过并且已经放到暂存区域的话，必须指定此选项
    - `--cached` 使Git不再继续跟踪该文件，但文件仍保存在磁盘中，类似于`.gitignore`

  ```shell
  # 直接删除file1.txt
  $ rm file1.txt
  
  # 查看文件状态
  $ git status
  On branch master
  Changes not staged for commit:
    (use "git add/rm <file>..." to update what will be committed)
    (use "git checkout -- <file>..." to discard changes in working directory)
  
          deleted:    file1.txt
  
  no changes added to commit (use "git add" and/or "git commit -a")
  
  # 记录删除操作到暂存区
  $ git add file1.txt
  
  # 查看文件状态
  $ git status
  On branch master
  Changes to be committed:
    (use "git reset HEAD <file>..." to unstage)
  
          deleted:    file1.txt
  
  # 使用git rm 命令删除file2.txt
  $ git rm file2.txt
  rm 'file2.txt'
  
  # 查看文件状态
  $ git status
  On branch master
  Changes to be committed:
    (use "git reset HEAD <file>..." to unstage)
  
          deleted:    file1.txt
          deleted:    file2.txt
  
  
  
  ```

  由此可见，执行`git rm 文件` 命令相当于执行了 ` rm 文件`命令和`git add 文件`命令，简化了操作

- **重命名文件**

  - `git mv 文件1 文件2` 相当于执行了：
    - `mv 文件1 文件2`
    - `git rm 文件1`
    - `git add 文件2`

  ```shell
  # 重命名文件
  $ git mv file3.txt file3_new.txt
  
  # 查看文件状态
  $ git status
  On branch master
  Changes to be committed:
    (use "git reset HEAD <file>..." to unstage)
  
          renamed:    file3.txt -> file3_new.txt
  ```

  

- **忽略文件**

  创建`.gitignore`文件声明某些文件无需纳入Git管理，也不需要出现在未跟踪文件列表。通常是自动生成的日志文件或编译过程中创建的临时文件等。

  格式规范:

  - 所有空行和以`#`开头的行都会被Git忽略
  - 可以使用标准的glob模式匹配（shell所使用的简化的正则表达式）
  - 匹配模式可以以`/`开头防止递归
  - 匹配模式可以以`/`结尾指定目录
  - 可在模式前加`!`取反

  看一个例子：

  ```shell
  # 忽略 .a结尾的文件
  *.a
  # 不忽略 lib.a文件
  !lib.a
  # 仅忽略当前目录下的 TODO, 不会忽略 subdir/TODO
  /TODO
  # 忽略 build目录及该目录下的所有文件
  build/
  # 忽略 doc/notes.txt, 但不忽略 doc/server/arch.txt
  doc/*.txt
  # 忽略所有doc目录下及doc子目录下以.pdf结尾的文件
  doc/**/*.pdf
  ```

  GitHub有一个十分详细得关于数十种项目及语言的`.ignore`[文件列表](https://github.com/github/gitignore)

### **6.3查看提交历史**



