---
title: 非权威指南-求职知识点汇总
header-img: back.png
header-color: 'rgb(247,122,96)'
tag-color: 'rgb(247,122,96)'
catalog: true
toc-number: false
date: 2020-02-20 16:48:43
tags: ['javaScript', '求职']
---

## 1. 简答题

#### 🎈 [] == [] 的输出结果是什么？ 为什么

> false  
>
> 因为“[]”是指向一块地址(空数组)的指针

### 🎈 [] == ![]结果是什么？为什么？

> false
>
> 左边空数组转为0，右边先转为 fasle， 再转为 0

#### 🎈 减少页面加载时间的办法？

> - 减少 http 请求 （合并文件、合并图片[雪碧图]）
> - 优化图片,采用正确的大小和格式
> - 压缩 CSS、js 文件
> - 使用 CDN

#### 🎈 什么情况下会有跨域问题？

> 请求的资源协议、主机 (域名)、端口有任意一个与所在域不同时

#### 🎈 http 协议中与资源缓存相关的协议头有哪些？

> ​	

#### 🎈 box-sizing 有哪些值？ 区别是什么？

> - content-box 默认值，标准盒模型。width 和 height 只包括内容，不包括 padding、border、margin
> - border-box  width 和 height 包括内容、padding、border，不包括 margin

#### 🎈 DOM Tree 和 Render Tree 的区别是什么？

> DOM Tree 是包含了所有的 HTML 标签，包括 display:node 和 js 动态添加的元素等
>
> Render Tree 是 DOM Tree 和 CSSOM 树组合成最终渲染在页面的树，每个节点都包含样式。不包含隐藏的节点。

#### 🎈 JavaScript 在什么情况下会发生装箱和拆箱？

> 装箱： 把基本类型转换成引用类型
>
> 拆箱： 把引用类型转换为基本类型	

### 🎈 为什么 typeof null === object

> 这是 JS 存在的一个悠久的 bug。 在早期 JS 使用的是 32 位系统，为了性能考虑用低位存储变量类型信息， 000 开头的是对象然而 null 全为 0，所以被错误得判断为 null

### 🎈 为什么 0.1 + 0.2 === 0.3 为 false

> 因为二进制浮点数中的 0.1 和 0.2 不是特别准确，它们相加的结果并非正好等于 0.3 而是0.30000000000000004, 所以结果为 false。可以使用 `Number.EPSILON` (机器精度) 解决这个问题
>
> ```js
> const result = 0.2 + 0.1
> 
> console.log(result === 0.3) // false
> console.log(result - 0.3 < Number.EPSILON)  // true
> ```

### 🎈 如何让if(a == 1 && a == 2)条件成立？

>  ```js
> var a = {
>   value: 0,
>   valueOf: function() {
>       return ++this.value
>   }
> }
>  ```

### 🎈 为什么  arguments 不是数组，怎么转换为数组

> 因为 arguments 不能使用数组的方法，所以 arguments 不是数组。它是类数组，属性从 0 开始牌，也有 length 和 callee 属性

转为数组：

- Array.from(arguments)
- […arguments]
- Array.prototype.slice.call(arguments, 0)
- Array.prototype.concat.apply([], arguments)
- 遍历

### 🎈 forEach 中 return 有结果吗，如何终止 forEach

> forEach 中 return 不会返回，函数会继续执行

终止方法

- try-catch
- 使用 every 和 some 替换

🎈 判断数组中是否包含某个值

- Array.prototype.indexOf()
- Array.prototype.lastIndexOf()
- Array.prototype.some(callback)
- Array.prototype.includes()     // includes 找到返回 true，没找到返回 false
- Array.prototype.find(callback)  // 返回满足条件的第一个值，没找到返回 undefined
- Array.prototype.findIndex(callback) // 返回满足条件的第一个值的索引，没找到返回 -1  

🎈 数组扁平化

- 递归

  ```js
  function _flat(arr, newArr = []) {
    for(var i = 0; i < arr.length; i++) {
      const item = arr[i]
      if(Array.isArray(item)) {
        _flat(item, newArr)
      }else{
        newArr.push(item)
      }
    }
    return newArr
  }
  ```

- 递归的 reduce 版本

  ```js
  function _flat(arr) {
    return arr.reduce((prev, next) => {
      return prev.concat(Array.isArray(next)? _flat(next) : next)
    }, [])
  }
  ```

- toString() + split() + map()

  适用于只有数字元素的情况，将其先转为字符串再转回为数字

  ```js
  function _flat(arr) {
    return arr.toString().split(",").map(item => + item)
  }
  ```

- JSON.stringify() + replace() + split()

  适用于只有数字

  ```js
  function _flat(arr) {
    let arrStr = JSON.stringify(arr)
    return arrStr.replace(/\[|\]/g,'').split(",").map(item => + item)
  }
  ```

- JSON.stringify() + JSON.parse()

  ```js
  function _flat(arr) {
    let arrStr = JSON.stringify(arr)
    arrStr =  '[' + arrStr.replace(/\[|\]/g,'') + ']'
    return JSON.parse(arrStr)
  }
  ```

- some + 三点运算符

  ```js
  function _flat(arr) {
    while(arr.some(item => Array.isArray(item))) {
      arr = [].concat(...arr)
    }
    return arr
  }
  ```

- flat

  ```js
  function flatArray(arr) {
   return arr.flat(Infinity)
  }
  ```

🎈

🎈

🎈

🎈

🎈

## 2. 代码分析题

### 🎈  写出下列代码的执行结果： 

```js
    new Promise((resolve) => {
console.log('1')
    resolve()
console.log('2')
     }).then(() => {
    console.log('3')
     })
     setTimeout(() => {
    console.log('4')
     })
     console.log('5')
```



🎈

🎈

🎈

🎈

🎈

## 3. 编程题

🎈实现 instanceof

```js
function _instanceof(left, right) {
  if(typeof left !== 'object') {
    return false
  }
  if(right === null){
    return false
  }
  let _prototype = right.prototype,
      proto = Object.getPrototypeOf(left)
  while(true) {
    if(proto === null) {
      return false
    }
    if(proto === _prototype) {
      return true
    }    
    proto = Object.getPrototypeOf(proto)
  }
}
```

### 🎈  实现 new

```js
function _new(constructor, ...args) {
  if(typeof constructor !== 'function') {
    throw new TypeError(callback + 'is not a funciton')
  }
  const obj = Object.create(constructor.prototype)
  const result = constructor.apply(obj, args)

  const isObject = typeof result === 'object' && result !== null
  const isFunction = typeof result === 'function' 
  
  return isObject || isFunction? result: obj
}

```

- 注意 isObject 要排除null 的情况
- 附加原型可以直接使用 Object.create() 方法

### 🎈 实现 call() / apply()

```js
Function.prototype._call = function (thisArg, ...args) {
  let func = this

  if(typeof func !== 'function') {
    throw new TypeError(func + 'is not a function')
  }

  // 确定全局对象, 在 thisArg 为 null 或 undefined
  // 并且运行在非严格模式下时把全局对象赋值给 thisArg
  let globalContex = typeof global !== 'undefined'? global: window
  let contex = thisArg || globalContex 

  let fn =  Symbol('fn')    // 创建一个独一无二的属性名
  contex[fn] = this		// 注意不能使用 contex.fn, 因为 fn 是一个变量名
  let result = contex[fn](...args)
  delete contex[fn]    // 删除给对象添加的属性
  return result
}
```

实现 call 与 apply 类似，只是定义函数时第二个参数为 `args` 不是 `...args`

### 🎈实现 bind()

```js
Function.prototype._bind = function (thisArg, ...args) {
  let target = this
  if(typeof target !== 'function') {
    throw new TypeError("target is not a funciton")
  }

  let bindedFn = function () {

    // 如果使用 new 调用不改变 this指向 
    return target.apply(this instanceof target? this: thisArg,     

      // 将调用 binddedFn 时传入的参数与 调用 bind 时给 target 传入的参数合并
      args.concat(Array.prototype.slice.call(arguments)))
  }
  
  bindedFn.prototype = Object.create(target.prototype)

  return bindedFn
}
```

### 🎈 实现浅拷贝

#### 1. 手动实现

````js
function shadowClone(target) {

  // 如果是基本类型，直接返回
  if (typeof target === 'object' && target !== null) {

    // 数组初始化为 [] , 对象初始化为 {}
    let cloneTarget = Array.isArray(target)? [] : {}

    // 遍历赋值，空元素跳过遍历
    for(let key in target) {
      if(target.hasOwnProperty(key)) {
        cloneTarget[key] = target[key]
      }
    }
    return cloneTarget
  } else {
    return target
  }
}
````

#### 2. Object.assign()

```js
function shadowClone(target) {
  return Object.assign(target)
}
```

#### 3. Array.prototype.slice()

只适用于数组

```js
function shadowClone(target) {
  return Array.prototype.slice(target)
}
```

#### 4. Array.prototype.concat()

只适用于数组

```js
function shadowClone(target) {
  return Array.prototype.concat(target)
}
```

#### 5. 展开运算符

```js
function shadowClone(target) {
  if (typeof target === 'object' && target !== null) {
    if (Array.isArray(target)) {
      return [...target]
    } else {}
    return {
      ...target
    }
  } else {
    return target
  }
}
```

### 🎈 实现深拷贝

#### 1. JSON.stringify() + JSON.parse()

```js
function deepClone(target) {
  return JSON.parse(JSON.stringify(target))
}
```

存在的问题:

- 无法拷贝函数、正则等特殊对象
- 无法解决循环引用

#### 2. 手动实现



